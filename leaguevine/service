#!/usr/bin/python
import sys

sys.path.append('..')
import os
import time
import pytz
import json
import requests
import traceback
import calendar
import re

from datetime import datetime
from calendar import timegm

from hosted import CONFIG
CONFIG.restart_on_update()

with file("windmill2016_test.json") as f:
    WINDMILL = json.load(f)

de_tz = pytz.timezone('Europe/Amsterdam')

tournaments = {}  # = Windmill divisions
teams = {}
schedule = WINDMILL['schedule']
brackets = {}

HOST = 'https://api.leaguevine.com/v1'
LOCALHOST = 'http://api.localhost:8000/v1'
# HOST = LOCALHOST

def lastround(datetime):
    # which round is currently being played?
    lastround = WINDMILL['schedule']['open'][0]
    lastround_start = datetime.strptime(lastround['start'], '%Y-%m-%dT%H:%M:%S')
    for round in WINDMILL['schedule']['open']:
        round_start = datetime.strptime(round['start'], '%Y-%m-%dT%H:%M:%S')
        round_end = datetime.strptime(round['end'], '%Y-%m-%dT%H:%M:%S')
        if round_start > lastround_start:
            lastround = round

    return lastround


def update(division='open'):
    tournament_id = WINDMILL['tournaments'][division]['tournament_id']
    # pull data from leaguevine
    r = requests.get('{0}/swiss_rounds/?tournament_id={1}'.format(HOST, tournament_id))
    swiss_rounds = r.json()['objects']
    # update schedule with extra information
    for swiss_round in swiss_rounds:
        # find the round in schedule[division] which corresponds to this swissround
        round = next((x for x in schedule[division] if x['start']==swiss_round['games'][0]['start_time'][0:19]), None)
        if round:
            round.update(swiss_round)
        else:
            print >> sys.stderr, "no matching round found, serious error!"

    # also update brackets here
    r = requests.get('{0}/brackets/?tournament_id={1}'.format(HOST, tournament_id))
    division_brackets = r.json()['objects']
    brackets[division] = division_brackets

def drop_division(division, name_string):
    if name_string[:5] == 'Test ':
        name_string = name_string[5:]
    name_string = name_string.replace(division + ' ', '')
    name_string = name_string.replace(division.capitalize() + ' ', '')
    name_string = name_string.replace(division, '')
    name_string = name_string.replace(division.capitalize(), '')
    return name_string

def game_to_dict(division, game):
    # takes in a leaguevine game, and returns a dictionary with the relevant information
    start_time = datetime.strptime(game['start_time'], '%Y-%m-%dT%H:%M:%S+02:00')
    game_dict = { 'team_1': '',
                  'team_2': '',
                  'team_1_country': '',
                  'team_2_country': '',
                  'field': '',
                  'field_nr': 0,
                  'team_1_score': game['team_1_score'],
                  'team_2_score': game['team_2_score'],
                  'is_final': game['winner_id'] is not None,
                  'start_time': start_time.strftime('%a %-H:%M'),
                  }
    if game['team_1']:
        game_dict['team_1'] = drop_division(division, game['team_1']['short_name'])
        game_dict['team_1_country'] = teams[game['team_1_id']]['country'].lower()
    if game['team_2']:
        game_dict['team_2'] = drop_division(division, game['team_2']['short_name'])
        game_dict['team_2_country'] = teams[game['team_2_id']]['country'].lower()
    if game['game_site']:
        game_dict['field'] = game['game_site']['name']
        game_dict['field_nr'] = int(re.sub("[^0-9]", "", game['game_site']['name']))

    return game_dict

def current_brackets(division='open'):
    curgames = []

    main_bracket = next((x for x in brackets[division] if len(x['rounds'])==3), None)
    for round in main_bracket['rounds']:
        if round['round_number']==2:
            # Quarterfinals
            for i,game in enumerate(round['games']):
                game_dict = game_to_dict(division, game)
                game_dict['name'] = 'QF{0}'.format(i)
                curgames.append(game_dict)
        elif round['round_number'] == 1:
            # Semifinals
            for i, game in enumerate(round['games']):
                game_dict = game_to_dict(division, game)
                game_dict['name'] = 'SF{0}'.format(i)
                curgames.append(game_dict)
        elif round['round_number'] == 0:
            # Final
            for i, game in enumerate(round['games']):
                game_dict = game_to_dict(division, game)
                game_dict['name'] = 'Fin12'
                curgames.append(game_dict)

    loser_bracket = next((x for x in brackets[division] if len(x['rounds'])==2), None)
    for round in loser_bracket['rounds']:
        if round['round_number']==1:
            # loser semis
            for i,game in enumerate(round['games'],start=2):
                game_dict = game_to_dict(division, game)
                game_dict['name'] = 'SF{0}'.format(i)
                curgames.append(game_dict)
        elif round['round_number'] == 0:
            # 5/6
            for i, game in enumerate(round['games']):
                game_dict = game_to_dict(division, game)
                game_dict['name'] = 'Fin56'
                curgames.append(game_dict)

    bronze_game = next((x for x in brackets[division] if 'bronze' in x['name']), None)
    if len(bronze_game['rounds']) > 1 or len(bronze_game['rounds'][0]['games']) > 1:
        print >> sys.stderr, "error: problem with updating bracket bronze game"
    else:
        game = bronze_game['rounds'][0]['games'][0]
        game_dict = game_to_dict(division, game)
        game_dict['name'] = 'Fin34'
        curgames.append(game_dict)

    game78 = next((x for x in brackets[division] if x['name'] == 'game for 7-8'), None)
    if len(game78['rounds']) > 1 or len(game78['rounds'][0]['games']) > 1:
        print >> sys.stderr, "error: problem with updating bracket game for place 7-8"
    else:
        game = game78['rounds'][0]['games'][0]
        game_dict = game_to_dict(division, game)
        game_dict['name'] = 'Fin78'
        curgames.append(game_dict)

    with file("current_brackets.json.new", "wb") as f:
        f.write(json.dumps(curgames,
                           ensure_ascii=False,
                           indent=2,
                           separators=(',', ':')
                           ).encode('utf8'))
    os.rename("current_brackets.json.new", "../current_brackets_{0}.json".format(division))

    print >> sys.stderr, "updated current brackets of {0} division".format(division)


def current_games(division='open', current_datetime=datetime.now()):
    print >> sys.stderr, "starting to update {0} division".format(division)

    tournament_id = WINDMILL['tournaments'][division]['tournament_id']
    # Check for games in this tournament that start later than now
    url = '{0}/games/'.format(HOST)
    payload = {'tournament_id': tournament_id,
               'starts_after': current_datetime.strftime('%Y-%m-%dT%H:%M:%S+02:00'),
               'limit': 50,
               'order_by': "['start_time','game_site_id']"}
    r = requests.get(url, params=payload)
    if r.json()['meta']['total_count'] == 0:
        # try 2 hours earlier (to catch the last round)
        payload['starts_after'] = (current_datetime-datetime.timedelta(hours=2)).strftime('%Y-%m-%dT%H:%M:%S+02:00')
        r = requests.get(url, params=payload)
        if r.json()['meta']['total_count'] == 0:
            print >> sys.stderr, "error: no games found"
    if r.json()['meta']['total_count'] > 20+12: # the 12 playoff games are also loaded here...
        print >> sys.stderr, "error: loaded two rounds instead of a single one"

    games = r.json()['objects']
    games_start = datetime.strptime(games[0]['start_time'], '%Y-%m-%dT%H:%M:%S+02:00')

    for round in WINDMILL['schedule'][division]:
        round_start = datetime.strptime(round['start'], '%Y-%m-%dT%H:%M:%S')

        if round_start == games_start:
            curgames = {'start_time': round_start.strftime('%a %-H:%M'),
                        'start_time_unix': int(timegm(round_start.timetuple())),
                        'round_name': round['name'],
                        'games': [],
                        'standings': round['standings']}

            # current standings
            # needs to be adjusted if Swissround higher than 5, because the 8 playoff teams are not in there anymore
            if round['round_number'] > 5:
                for stand in curgames['standings']:
                    stand['ranking'] += 8

            # TODO: figure out the "standings" in the playoff brackets and insert into standings

            for stand in curgames['standings']:
                stand['team_country'] = teams[stand['team_id']]['country'].lower()
                stand['team_name'] = u'flag:{0} {1}'.format(teams[stand['team_id']]['country'].lower(), drop_division(division, stand['team']['short_name']))

            break


    for game in games:
        if game['team_2_id'] and datetime.strptime(game['start_time'], '%Y-%m-%dT%H:%M:%S+02:00') == games_start:  # not a  BYE  and  same start as first game
            curgames['games'].append(game_to_dict(division, game))

    with file("current_games.json.new", "wb") as f:
        f.write(json.dumps(curgames,
                           ensure_ascii=False,
                           indent=2,
                           separators=(',', ':')
                           ).encode('utf8'))
    os.rename("current_games.json.new", "../current_games_{0}.json".format(division))

    print >> sys.stderr, "updated current games and standings of {0} division".format(division)


def leaguevine_basic_info():
    global teams
    tournament_ids = [t['tournament_id'] for name, t in WINDMILL['tournaments'].items()]
    # retrieve tournament info  ( = Windmill divisions)
    url = '{0}/tournaments/'.format(HOST)
    payload = {'tournament_ids': '{0}'.format(tournament_ids).replace(' ', '')}
    r = requests.get(url, params=payload)
    tournaments = r.json()['objects']

    # retrieve tournament teams (to figure out which teams are playing in which tournaments
    payload['fields'] = '[team_id,tournament_id]'
    payload['limit'] = 200
    r = requests.get('{0}/tournament_teams/'.format(HOST), params=payload)
    result = r.json()
    if result['meta']['next']:
        print >> sys.stderr, "only 200 teams were loaded, but there are more!"
    all_team_ids = []
    for tournament in tournaments:
        tournament['team_ids'] = [x['team_id'] for x in result['objects'] if x['tournament_id'] == tournament['id']]
        all_team_ids.extend(tournament['team_ids'])
    # make all_team_ids unique and sorted
    all_team_ids = sorted(set(all_team_ids))

    # retrieve all team info
    url = '{0}/teams/'.format(HOST)
    payload = {'team_ids': '{0}'.format(all_team_ids).replace(' ', ''),
               'limit': 200}
    r = requests.get(url, params=payload)
    result = r.json()
    teams = {team['id']: team for team in result['objects']}

    return True


def main():
    leaguevine_basic_info()
    # update('mixed')
    # current_games('mixed', datetime(2016, 04, 16, 22, 31, 00))
    # current_brackets('mixed')
    #
    # return True
    while 1:
        for division in ['open', 'mixed', 'women']:
        # for division in ['women']:
            try:
                update(division)
                current_games(division, datetime(2016, 04, 16, 22, 31, 00))
                current_brackets(division)
            except:
                print >> sys.stderr, "failed to update {0} division".format(division)
                traceback.print_exc()
                # time.sleep(20)
                continue

        time.sleep(60)


if __name__ == "__main__":
    main()
